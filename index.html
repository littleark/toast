<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>toast</title>
	<link rel="stylesheet" href="css/toast.css">
	<link rel="stylesheet" href="css/chart.css">
	<script type="text/javascript" src="js/vendors/dat.gui.min.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.11/d3.min.js" charset="utf-8"></script>
	<script>window.d3||document.write('<script src="js/vendors/d3/d3.min.js"><\/script>');</script>
</head>
<body>
	<div id="toast"></div>
	<div id="angle_vs_y"></div>
	<div id="angle_vs_t"></div>
	<div id="angle_vs_xy"></div>
	<script src="js/Chart.js"></script>
	<script>


		var sin=Math.sin,
			cos=Math.cos,
			RAD2DEG=180/Math.PI;

		var data={
				table:{
					x:0,
					y:0.76, //table height m
					w:0.6, //table width
					h:0.03 //table thickness
				},
				physics:{
					g:9.81, // gravity acceleration
					dt:0.01 //sampling time s
				},
				toast: {
					a: 0.15, //bread dimension m (area=a*a)
					m: 24.0, //bread weight gr
					h: 0.014, // thickness of the toast m
					r: 0.01, //initial hoverang m
					f:0.5 //dynamic friction coefficient
				},
				positions:[],
				end:{

				}
			};



		console.log(data)
		

		function calculateStatuses(options) {
			if(options) {
				console.log("############ SIMULATION #############");
			}

			var statuses=[];

			var counter = 0;

			var t = 0,
				Fp = 0, //perpendicular force
				Ff = 0, //friction force
				JC, //moment of inertia
				vr = 0,
				ar = 0,
				Om = 0,
				aphi = 0,
				r = (options && options.toast && options.toast.r)?options.toast.r:data.toast.r,
				m = (options && options.toast && options.toast.m)?options.toast.m:data.toast.m,
				a = (options && options.toast && options.toast.a)?options.toast.a:data.toast.a,
				f = (options && options.toast && options.toast.f)?options.toast.f:data.toast.f,
				g = (options && options.physics && options.physics.g)?options.physics.g:data.physics.g,
				dt = (options && options.physics && options.physics.dt)?options.physics.dt:data.physics.dt,
				h = (options && options.table && options.table.y)?options.table.y:data.table.y;

			var xC=0,
				yC=0,
				phi=0; //bread angle rad

			JC = m*a*a/3;
			Fp = m*JC/(JC+m*r*r)*(g*cos(phi)-2*vr*Om);

			//console.log(JC,Fp);

			statuses.push({
				t:t,
				x:r,
				y:h-yC,
				rad:phi,
				deg:phi*RAD2DEG,
				p:++counter,
				table:1
			});
			//r=0;
			if(r===0) {
				debug("Toast not leaving the table "+h+"m");
				if(!options) {
					data.statuses=statuses;
				} else {
					console.log("############ END SIMULATION #############");
					options.statuses=statuses;
				}
				return;
			}

			while (Fp>0) {  // table loop

				Fp = m*JC/(JC+m*r*r)*(g*cos(phi)-2*vr*Om);
				Ff = f*Fp;

				aphi= (r/JC)*Fp;
				ar = -Ff/m + r*Om*Om + g*sin(phi);
				if (ar<0) ar = 0;

				Om = Om + aphi*dt;
				vr = vr + ar*dt;

				r = r + vr*dt;
				phi = phi + Om*dt;
				xC = r*cos(phi); 
				yC = r*sin(phi);

				t = t + dt;

				statuses.push({
					t:t,
					x:xC,
					y:h-yC,
					rad:phi,
					deg:phi*RAD2DEG,
					p:counter,
					table:1
				});

				counter++;

			}  // end table loop
			
			debug("Condition leaving the table "+h+"m");

			
			var vfx = vr*cos(phi),
				vfy = vr*sin(phi);

			while (yC < h-a/2) {

				vfy = vfy + g*dt;
				xC = xC + vfx * dt;
				yC = yC + vfy * dt;
				phi = phi + Om*dt;

				t = t + dt;

				//debug();
				
				statuses.push({
					t:t,
					x:xC,
					y:h-yC,
					rad:phi,
					deg:phi*RAD2DEG,
					p:counter,
					table:0
				});
				
				counter ++;

			}



			debug("Final conditions");

			if (cos(phi) >0) {
				console.log("BREAD SIDE");
			} else {
				console.log("BUTTER SIDE");
			}

			if(!options) {
				data.statuses=statuses;
			} else {
				console.log("############ END SIMULATION ############# statuses",statuses.length);
				options.statuses=statuses;
			}

			function debug(condition) {
				console.log("####################################");
				if(condition) {
					console.log(condition);
				}
				console.log(
						"N",counter+"",
						"Fp",Fp+"",
						"Ff",Ff+"",
						"aphi",aphi+"",
						"ar",ar+"",
						"Om",Om+"",
						"phi",phi+"",
						"deg",(phi*RAD2DEG)+"",
						"vr",vr+"",
						"r",r+"",
						"t",t+"",
						"xC",xC+"",
						"yC",yC+""
					);
				console.log("####################################");
			}
		}
		calculateStatuses();

		console.log(data.positions)
		console.log(data.statuses)

		

		var WIDTH=500,
			HEIGHT=500;

		var margins={
			top:20,
			bottom:20,
			left:30,
			right:30
		}

		var svg=d3.select("#toast")
					.append("svg")
					.attr("width",WIDTH)
					.attr("height",HEIGHT);

		var xscale=d3.scale.linear().domain([0,1]).range([0,WIDTH-(margins.left+margins.right)]),
			yscale=d3.scale.linear().domain([0,1]).range([HEIGHT-(margins.top+margins.bottom),0]),
			hscale=d3.scale.linear().domain([0,1]).range([0,HEIGHT-(margins.top+margins.bottom)])

		
		
		var world=svg.append("g")
						.attr("id","world")
						.attr("transform","translate("+margins.left+","+margins.top+")")

		var table=world.append("g")
					.attr("id","table")
					.attr("transform",function(){

						var x=xscale(data.table.x),
							y=yscale(data.table.y);

						return "translate("+x+","+y+")";
					});
		table.append("rect")
				.attr("x",0)
				.attr("y",0)
				.attr("width",xscale(data.table.w))
				.attr("height",hscale(data.table.h));

		table.append("line")
				.attr("class","dropline")
				.attr("x1",xscale(data.table.x)+xscale(data.table.w))
				.attr("y1",0)
				.attr("x2",xscale.range()[1])
				.attr("y2",0)


		var floor=world.append("g")
					.attr("id","floor")
					.attr("transform","translate(0,"+yscale.range()[0]+")")
					.append("rect")
						.attr("x",0)
						.attr("y",0)
						.attr("width",xscale.range()[1])
						.attr("height",3)


		var toast=world.append("g")
					.attr("id","toast");

		var angle=world.append("g")
					.attr("class","angle")
					.attr("transform",function(){
						var x=xscale(data.table.x+data.table.w)+30,
							y=yscale.range()[0]-10;
						return "translate("+x+","+y+")"
					})
					.append("text")
						.attr("x",0)
						.attr("y",0)
						//.html(d3.round(data.end.thetaDeg,3)+"&deg;")
						.html(d3.round(data.statuses[data.statuses.length-1].deg,3)+"&deg;")

		update();

		

		//AXIS

		var xAxis = d3.svg.axis().scale(xscale).orient("top");
		var yAxis = d3.svg.axis().scale(yscale).orient("right");

		var axes=svg.append("g")
						.attr("id","axes")
						.attr("transform","translate("+margins.left+","+margins.top+")")

		axes.append("g")
	      .attr("class", "x axis")
	      .attr("transform", "translate(0,0)")
	      .call(xAxis)

	   	axes.append("g")
	      .attr("class", "y axis")
	      .attr("transform", "translate("+(WIDTH-(margins.left+margins.right))+",0)")
	      .call(yAxis)

	    function update() {
	    	//data.end=calculateTimeAngle();
	    	//calculateAllPositions();

	    	calculateStatuses();
	    	data.end=data.statuses[data.statuses.length-1].deg;
			
			console.log("UPDATE DATA:",data)	    	

	    	var toasts=toast.selectAll("g.toast")
						//.data(data.positions,function(d,i){
						.data(data.statuses.filter(function(d,i){
							return 1;
							return d.y>0;
						}),function(d,i){
							return "p"+d.p;
						});

			var new_toasts=toasts
								.enter()
								.append("g")
									.attr("class","toast")
									.attr("rel",function(d){
										//console.log("rel",d.p)
										return d.p+": "+d.y+","+d.deg;
									})
									.attr("transform",function(d,i){
										var x=xscale(data.table.w+d.x),
											y=yscale(d.y);//-hscale(data.toast.h/2),
											//dy=0;//y-yscale(data.table.y);



										return "translate("+(x)+","+y+")"
									})
									.on("mouseover",function(){
										var sel = d3.select(this);
										sel.moveToFront();
									})
							

			toasts.exit().remove();

			new_toasts.append("line")
					.attr("class","x dropline")
					.attr("x1",0)
					.attr("x2",function(d){
						var w=xscale(1)-xscale(data.table.w+d.x);
						return w;
					})
					.attr("y1",0)
					.attr("y2",0)

			new_toasts.append("line")
					.attr("class","y dropline")
					.attr("x1",0)
					.attr("x2",0)
					.attr("y1",0)
					.attr("y2",function(d){
						var h=-(yscale(d.y));//-yscale(1)-hscale(data.toast.h/2));
						return h;
					})

			var g=new_toasts.append("g")

			g.append("rect")
					.attr("x",-xscale(data.toast.a/2))
					.attr("y",-hscale(data.toast.h))
					.attr("width",hscale(data.toast.a))
					.attr("height",hscale(data.toast.h))

			g.append("line")
					.attr("class","butter")
					.attr("x1",-xscale(data.toast.a/2))
					.attr("y1",-hscale(data.toast.h))
					.attr("x2",xscale(data.toast.a/2))
					.attr("y2",-hscale(data.toast.h))


			g.append("circle")
					.attr("cx",0)
					.attr("cy",0)
					.attr("r",1)

			g.append("circle")
					.attr("class","center")
					.attr("cx",function(d){
						var x=xscale(d.x)
						return -x;
					})
					.attr("cy",0)
					.attr("r",1)
					.style("fill","#ff6600")

			toasts.select("rect")
					.attr("x",-xscale(data.toast.a/2))
					.attr("width",xscale(data.toast.a))

			toasts.select("line.butter")
					.attr("class","butter")
					.attr("x1",-xscale(data.toast.a/2))
					.attr("x2",xscale(data.toast.a/2))

			toasts.select("line.x.dropline")
					.attr("x2",function(d){
						var w=xscale(1)-xscale(data.table.w+data.toast.r+d.x);
						return w;
					})

			toasts.select("line.y.dropline")
					.attr("y2",function(d){
						var h=-(yscale(d.y));
						return h;
					})

			toasts
				.transition()
				.duration(1000)
				.attr("transform",function(d,i){
					var x=xscale(data.table.w+d.x),
						y=yscale(d.y);//-hscale(data.toast.h/2);
					//y=yscale(data.table.y);

					return "translate("+x+","+y+")";
				})
				.select("g")
					.attr("transform",function(d){
						if(d.table) {
							
							var dx=xscale(d.x),
								dy=yscale.range()[0] - yscale(data.table.y-d.y)
							
							console.log("----> X",d.x,dx)
							console.log("----> Y",data.table.y,d.y,data.table.y-d.y,dy)
							//console.log("---------->",d.x,d.y,data.table.y,dx,dy)
							dx=dy=0;
							return "rotate("+d.deg+","+(dx)+","+(-dy)+")";	
						}
						return "rotate("+d.deg+")";	
						
					})
			toasts
				.select("circle.center")
					.attr("cx",function(d){
						//return -(xscale(data.toast.r));
						if(d.table) {
							var dx=d.x/Math.cos(d.rad);
							console.log("DEG ",d.deg,"DX",dx,"->",xscale(dx))
							return -(xscale(dx));
						} else {
							return 0;
						}
					})
					

			table
				.transition()
				.duration(1000)
				.attr("transform",function(){

					var x=xscale(data.table.x),
						y=yscale(data.table.y);


					return "translate("+x+","+y+")";
				});

			angle.html(d3.round(data.end,3)+"&deg;")

			world.select("g.angle")
				.attr("transform",function(){
					var d=toasts.data()[toasts.data().length-1];
					var x=xscale(data.table.x+data.table.w)+d.x,
						y=yscale(d.y);
					return "translate("+x+","+y+")"
				})
				.select("text")
					.html(d3.round(data.statuses[data.statuses.length-1].deg,3)+"&deg;");

			

	    }

	    var simulation={
			table: {
				y:10
			},
			physics:{
				dt:0.001 //sampling time s
			},
			toast:{
				
			}
		}
		calculateStatuses(simulation);

		console.log(simulation)

		var PHIvsYChart=new Chart([
				{
					name:"line1",
					strokeWidth:3,
					data:simulation.statuses.map(function(d){
						return {
							x: -d.y+(simulation.table.y),
							y: Math.cos(d.rad)
						}
					})
				}
			],{
				container:"#angle_vs_y",
				width:760,
				height:300,
				invertedAxis:false,
				showZeroAxis:true
				//interpolate:"monotone"
			});

		var PHIvsTChart=new Chart([
				{
					name:"line2",
					strokeWidth:3,
					data:simulation.statuses.map(function(d){
						return {
							x: d.t,
							y: Math.cos(d.rad)
						}
					})
				}
			],{
				container:"#angle_vs_t",
				width:760,
				height:300,
				invertedAxis:false,
				showZeroAxis:true
				//interpolate:"monotone"
			});

		var PHIvsXYChart=new Chart([
				{
					name:"lineY",
					stroke:"#336699",
					strokeWidth:3,
					data:simulation.statuses.map(function(d){
						console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!",d.y)
						return {
							x: d.t,
							y: (simulation.table.y - d.y)
						}
					})
				},
				{
					name:"lineX",
					stroke:"#a0091d",
					strokeWidth:3,
					data:simulation.statuses.map(function(d){
						return {
							x: d.t,
							y: d.x
						}
					})
				}
			],{
				container:"#angle_vs_xy",
				width:760,
				height:300,
				invertedAxis:false
				//interpolate:"monotone"
			});

		function simulate(options) {
		
			simulation.toast.r=data.toast.r;
			if(options && options.toast && options.toast.r) {
				simulation.toast.r = options.toast.r;
			}

			simulation.toast.m=data.toast.m;
			if(options && options.toast && options.toast.m) {
				simulation.toast.m = options.toast.m;
			}

			simulation.toast.a=data.toast.a;
			if(options && options.toast && options.toast.a) {
				simulation.toast.a = options.toast.a;
			}

			simulation.toast.f=data.toast.f;
			if(options && options.toast && options.toast.f) {
				simulation.toast.f = options.toast.f;
			}

			//simulation.table.y=2;
			calculateStatuses(simulation);
			console.log("SHITEEEEEEEEEEEEEEEEE")
			console.log(simulation)
			PHIvsYChart.update([
				{
					name:"line1",
					data:simulation.statuses.map(function(d){
						return {
							x: -d.y+(simulation.table.y),
							y: Math.cos(d.rad)
						}
					})
				}
			]);
			PHIvsTChart.update([
				{
					name:"line2",
					data:simulation.statuses.map(function(d){
						return {
							x: d.t,
							y: Math.cos(d.rad)
						}
					})
				}
			]);
			PHIvsXYChart.update([
				{
					name:"lineY",
					data:simulation.statuses.map(function(d){
						return {
							x: d.t,
							y: (simulation.table.y - d.y)
						}
					})
				},
				{
					name:"lineX",
					data:simulation.statuses.map(function(d){
						return {
							x: d.t,
							y: d.x
						}
					})
				}
			]);
		}
		

	    var gui = new dat.GUI();
		//gui.add(text, 'message');
		//gui.add(text, 'speed', -5, 5);
		//gui.add(text, 'displayOutline');
		//gui.add(text, 'explode');
		var controllers={
			tableH:gui.add(data.table, "y", 0.1,0.9),
			bread_size:gui.add(data.toast, "a", 0.1,0.2).step(0.01),
			overhang:gui.add(data.toast, "r", 0.0,0.05).step(0.01),
			friction:gui.add(data.toast, "f", 0.1,0.6).step(0.1),
			bread_weight:gui.add(data.toast, "m", 10,30).step(1),
			dt:gui.add(data.physics, "dt", 0.01,0.1).step(0.01)
		}
		

		controllers["tableH"].onFinishChange(function(value) {
		  // Fires when a controller loses focus.
		  update();
		});

		controllers["bread_size"].onFinishChange(function(value) {
		  // Fires when a controller loses focus.
		  update();
		  simulate();
		});

		controllers["bread_weight"].onFinishChange(function(value) {
		  // Fires when a controller loses focus.
		  update();
		  simulate();
		});	

		controllers["overhang"].onFinishChange(function(value) {
		  // Fires when a controller loses focus.
		  update();
		  simulate();
		});

		controllers["friction"].onFinishChange(function(value) {
		  // Fires when a controller loses focus.
		  update();
		  simulate();
		});

		controllers["dt"].onFinishChange(function(value) {
		  // Fires when a controller loses focus.
		  update();
		});		

		d3.selection.prototype.moveToFront = function() {
		  return this.each(function(){
		    this.parentNode.appendChild(this);
		  });
		};
	</script>
</body>
</html>